<!DOCTYPE html>
<html lang="en">
<!-- 
This software is provided under the BSD License. Copyright (c) 2024 Xavier de Carné de Carnavalet.
Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the original author is acknowledged. See JavaScript source for full license text.
-->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat Application</title>
    <!-- Bootstrap CSS for styling -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <!-- Custom CSS -->
    <link href="{{ url_for('static', filename='styles.css') }}" rel="stylesheet">
    <!-- <script type = "text/javascript" src="generateKeyPair.js"></script> -->
</head>
<body>
<div class="container mt-4">
    <h2>Chat Application <small> - (<a href="/logout">Logout</a>)</small></h2>
    <div class="chat-box">
        <!-- Chat messages container -->
        <div id="messages" style="border:1px solid #ccc; height:300px; margin-bottom:20px; overflow-y:scroll; padding:10px;"></div>
        <!-- User selection dropdown -->
        <select id="userList" class="form-control mb-2">
            <option value="-1" disabled selected><i>Choose a contact</i></option>
            <!-- User options populated here -->
        </select>
        <!-- Message input -->
        <textarea id="messageInput" class="form-control mb-2" placeholder="Type a message..."></textarea>
        <div class="d-flex justify-content-between">
            <button onclick="sendInputMessage()" class="btn btn-primary">Send</button>
            <button onclick="initial_ECDH()" class="btn btn-primary">generateKeyEC</button>
            <div>
                <button onclick="refreshKeys()" class="btn btn-secondary btn-sm">Refresh Keys</button>
                <button onclick="eraseChat()" class="btn btn-danger btn-sm">Erase Chat</button>
            </div>
        </div>
    </div>
</div>

<!-- jQuery for simplified JavaScript -->
<script src="https://code.jquery.com/jquery-3.7.1.min.js" integrity="sha384-1H217gwSVyLSIfaLxHbE7dRb3v4mYCKbpQvzx0cegeju1MVsGrX5xXxAvs/HgeFs" crossorigin="anonymous"></script>
<script type="text/javascript">

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Global variables
let lastMessageId = 0;
let peer_id = -1;
const myID = {{ sender_id }};
let userInfo = {};
let myKeyPair;
let otherPublicKey;
let mySecretKey;
let myExportPublicKey;

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Ctrl+Enter to send message
document.addEventListener('DOMContentLoaded', function() {
    document.getElementById('messageInput').addEventListener('keydown', function(e) {
        if (e.ctrlKey && e.key === 'Enter') {
            sendMessage();
        }
    });
});

function sendInputMessage(){
    sendMessage("normal");
}
function sendECDH_request(){
    sendMessage("ECDH request");
}
function sendECDH_response(){
    sendMessage("ECDH response");
}
function sendRefreshKeyinit(){
  sendMessage("refresh key");
}
function sendRefreshKeyreply(){
  sendMessage("refresh key");
}

// Send message function
async function sendMessage(type) {
    if (peer_id == -1) return; // Exit if no peer selected
    let message0,message;
    let status = 'n';
    let value = '';
    let tag = '';
    let iv = '';
    let counter = '';
    if (type=='normal') {
        counter = JSON.parse(localStorage.getItem('secret_bits_counter_'+peer_id.toString())).toString();
        message0 = document.getElementById('messageInput').value;
        message = await encryptMessage(message0);
        // message = message0;
        iv = (JSON.parse(localStorage.getItem("encryption_iv_"+peer_id.toString()+"_"+counter.toString()))).toString();
        tag = await signiv();
    }
    if (type=='ECDH request'||type=='ECDH response') {
        message0 = myExportPublicKey;
        message = message0;
    }
    if (type=='refresh key'){
        counter = JSON.parse(localStorage.getItem('secret_bits_counter_'+peer_id.toString())).toString();
        message0 = "Keys changed";
        message = await encrypt_changeKey_Message(message0);
        // message = message0;
        iv = (JSON.parse(localStorage.getItem("encryption_iv_"+peer_id.toString()+"_"+counter.toString()))).toString();
        tag = await signiv();
        // iv = '';
    }
    // const message = message0;
    const payload = {
        receiver_id: peer_id,
        message_text: message,
        message_type: type,
        message_iv: iv,
        message_value: value,
        message_tag: tag,
        message_secret_counter: counter,
    };
    console.log(JSON.stringify(payload));

    fetch('/send_message', {
        method: 'POST', // Specify the method
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
    })
    .then(response => {
        if (!response.ok) {
            // If the server response is not OK, throw an error
            throw new Error('Network response was not ok');
        }
        return response.json(); // Parse JSON response from the server
    })
    .then(data => {
        console.log('Message sent:', data); // Log success message
        document.getElementById('messageInput').value = ''; // Clear the input after sending
    })
    .catch(error => {
        console.error('Error sending message:', error); // Log any errors
    });
}



// Populate users function
// document is the webpage. we define the id in the html. now we can get it
function populateUsers(users) {
    const userListDropdown = document.getElementById("userList");
    users.forEach(user => {
        const option = new Option(user[1], user[0]); // username as text, user_id as value
        userListDropdown.add(option);
    });
}

// Fetch users from server
$(document).ready(function() {
    fetch('/users')
        .then(response => response.json())
        .then(data => {
            data.users.forEach(user => {
                userInfo[user[0]] = user[1]; // Map user_id to username
            });
            console.log(userInfo);
            populateUsers(data.users);
        })
        .catch(error => console.error('Error fetching user info:', error));
});

// Handle user selection change
document.getElementById('userList').addEventListener('change', event => {
    peer_id = parseInt(event.target.value, 10); // Convert selected peer_id to integer
    clearChatBox();
    lastMessageId = 0;
    fetchMessages(); // Fetch messages for the new selection
});

// Clear chat box
function clearChatBox() {
    document.getElementById('messages').innerHTML = '';
}

// Fetch messages from server
function fetchMessages() {
    if (peer_id === -1) return; // Exit if no peer selected
    fetch(`/fetch_messages?last_message_id=${lastMessageId}&peer_id=${peer_id}`)
        .then(response => response.json())
        .then(data => {
            data.messages.forEach(async(message) => {
                await displayMessage(message);
                lastMessageId = message.message_id;
                console.log(message.message_type);
                if (message.message_type == "ECDH request" && message.sender_id == peer_id){
                    reply_to_ECDH(message.message_text);
                }
                if (message.message_type=='ECDH response' && message.sender_id == peer_id){
                    receive_ECDH_response(message.message_text);
                }

            });
        })
        .catch(error => console.error('Error fetching messages:', error));
}

// Display a single message
async function displayMessage(message) {
  // try{
    const messagesContainer = document.getElementById('messages');
    const messageElement = document.createElement('div');

    // Determine sender and receiver strings
    const sender = message.sender_id == myID ? "me" : (userInfo[message.sender_id] || `User ${message.sender_id}`);
    const receiver = message.receiver_id == myID ? "me" : (userInfo[message.receiver_id] || `User ${message.receiver_id}`);
    console.log("this");
    if (message.message_type=="normal"){
      console.log("sadd");
      let text = await decryptMessage(message);
      messageElement.textContent = `From ${sender} to ${receiver}: ${text}`;
      // console.log("message:",messageElement.textContent);
    }else {
      messageElement.textContent = `From ${sender} to ${receiver}: ${message.message_text}`;
    }
    // messageElement.textContent = `From ${sender} to ${receiver}: ${message.message_text}`;
    // console.log(messageElement.textContent);
    messagesContainer.appendChild(messageElement);
//   }catch(e) {
//     console.log(e.name, e.message);
// }
  // }
  


}

// Periodically fetch new messages every second
setInterval(fetchMessages, 1000);

// Erase Chat function using fetch API
function eraseChat() {
    if (peer_id === -1) return; // Exit if no peer selected
    if (!confirm('Are you sure you want to erase the chat with '+userInfo[peer_id]+'?')) return; // Confirmation before erasing

    fetch(`/erase_chat`, {
        method: 'POST',  // A REST API should use POST if it leads to modifications
        headers: {
            'Content-Type': 'application/json', 
        },
        body: JSON.stringify({ peer_id: peer_id })
    })
    .then(response => {
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        return response.json(); // Assuming the server responds with JSON
    })
    .then(data => {
        console.log('Chat erased:', data);
        clearChatBox(); // Clear the chat display
    })
    .catch(error => {
        console.error('Error erasing chat:', error);
    });
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

async function initial_ECDH(){
    await generateKey();
    sendECDH_request();
}

async function receive_ECDH_response(otherpublickey){
    await generate_secret_key(otherpublickey);
    await generate_edmac_key_user1();
}

async function reply_to_ECDH(otherpublickey){
    await generateKey();
    await sendECDH_response();
    await generate_secret_key(otherpublickey);
    await generate_edmac_key_user2();
}

async function generate_edmac_key_user1(){
    let keyMaterial =await get_shared_secret_key();
    console.log(typeof keyMaterial);
    console.log(keyMaterial);
    let count = JSON.parse(localStorage.getItem('secret_bits_counter_'+peer_id.toString()))+1;
    localStorage.setItem('secret_bits_counter_'+peer_id.toString(), JSON.stringify(count));
    let encryption = await getKey(keyMaterial, 2*count-1, "CHAT_KEY_"+myID+"to"+peer_id.toString());
    let decryption = await getKey(keyMaterial, 2*count, "CHAT_KEY_"+peer_id.toString()+"to"+myID);
    console.log(encryption);
    console.log(decryption);

    // buffer array
    const encryption_exported = await window.crypto.subtle.exportKey("raw",encryption);
    let encryption_str = getArrayBufferString(encryption_exported);
    localStorage.setItem("CHAT_KEY_USER"+myID.toString()+"to"+peer_id.toString()+"_"+count.toString(),encryption_str);
    const decryption_exported = await window.crypto.subtle.exportKey("raw",decryption);
    let decryption_str = getArrayBufferString(decryption_exported);
    localStorage.setItem("CHAT_KEY_USER"+peer_id.toString()+"to"+myID.toString()+"_"+count.toString(),decryption_str);
    localStorage.setItem("encryption_iv_"+peer_id.toString()+"_"+count.toString(),0);
    localStorage.setItem("decryption_iv_"+peer_id.toString()+"to"+myID.toString()+"_"+count.toString(),0);
    localStorage.setItem("decryption_iv_"+myID.toString()+"to"+peer_id.toString()+"_"+count.toString(),0);

    let mac_me = await getmacKey(keyMaterial, 2*count-1, "CHAT_MAC_"+myID+"to"+peer_id.toString());
    let mac_other = await getmacKey(keyMaterial, 2*count, "CHAT_MAC_"+myID+"to"+peer_id.toString());
    console.log(mac_me);
    console.log(mac_other);
    
    mac_me_exported = await window.crypto.subtle.exportKey("jwk",mac_me);
    // console.log(typeof mac_me_exported);
    localStorage.setItem("CHAT_MAC_USER"+myID.toString()+"to"+peer_id.toString()+"_"+count.toString(),JSON.stringify(mac_me_exported));
    mac_other_exported = await window.crypto.subtle.exportKey("jwk",mac_other);
    localStorage.setItem("CHAT_MAC_USER"+peer_id.toString()+"to"+myID.toString()+"_"+count.toString(),JSON.stringify(mac_other_exported));


}

async function generate_edmac_key_user2(){
    let keyMaterial =await get_shared_secret_key();
    console.log(typeof keyMaterial);
    console.log(keyMaterial);
    let count = JSON.parse(localStorage.getItem('secret_bits_counter_'+peer_id.toString()))+1;
    localStorage.setItem('secret_bits_counter_'+peer_id.toString(), JSON.stringify(count));
    let decryption = await getKey(keyMaterial, 2*count-1, "CHAT_KEY_"+myID.toString()+"to"+peer_id.toString());
    let encryption = await getKey(keyMaterial, 2*count, "CHAT_KEY_"+peer_id.toString()+"to"+myID.toString());
    
    const encryption_exported = await window.crypto.subtle.exportKey("raw",encryption);
    let encryption_str = getArrayBufferString(encryption_exported);
    localStorage.setItem("CHAT_KEY_USER"+myID.toString()+"to"+peer_id.toString()+"_"+count.toString(),encryption_str);
    const decryption_exported = await window.crypto.subtle.exportKey("raw",decryption);
    let decryption_str = getArrayBufferString(decryption_exported);
    localStorage.setItem("CHAT_KEY_USER"+peer_id.toString()+"to"+myID.toString()+"_"+count.toString(),decryption_str);
    localStorage.setItem("encryption_iv_"+peer_id.toString()+"_"+count.toString(),0);
    localStorage.setItem("decryption_iv_"+myID.toString()+"to"+peer_id.toString()+"_"+count.toString(),0);
    localStorage.setItem("decryption_iv_"+peer_id.toString()+"to"+myID.toString()+"_"+count.toString(),0);

    let mac_other = await getmacKey(keyMaterial, 2*count-1, "CHAT_MAC_"+myID+"to"+peer_id.toString());
    let mac_me = await getmacKey(keyMaterial, 2*count, "CHAT_MAC_"+myID+"to"+peer_id.toString());
    console.log(mac_me);
    console.log(mac_other);

    mac_me_exported = await window.crypto.subtle.exportKey("jwk",mac_me);
    // console.log(typeof mac_me_exported);
    localStorage.setItem("CHAT_MAC_USER"+myID.toString()+"to"+peer_id.toString()+"_"+count.toString(),JSON.stringify(mac_me_exported));
    mac_other_exported = await window.crypto.subtle.exportKey("jwk",mac_other);
    localStorage.setItem("CHAT_MAC_USER"+peer_id.toString()+"to"+myID.toString()+"_"+count.toString(),JSON.stringify(mac_other_exported));
}

  /*
  Given some key material and some random salt,
  derive an AES-GCM key using HKDF.
  */
  function getKey(keyMaterial, saltnum, information) {
    return window.crypto.subtle.deriveKey(
      {
        name: "HKDF",
        salt: saltnumToUint8Array(saltnum),
        info: new Uint8Array(information),
        hash: "SHA-256",
      },
      keyMaterial,
      { name: "AES-GCM", length: 256 },
      true,
      ["encrypt", "decrypt"]
    );
  }
  
  function getmacKey(keyMaterial, saltnum, information) {
    return window.crypto.subtle.deriveKey(
      {
        name: "HKDF",
        salt: saltnumToUint8Array(saltnum),
        info: new Uint8Array(information),
        hash: "SHA-256",
      },
      keyMaterial,
      { name: "HMAC", 
        hash: "SHA-256",
        length: 256 },
      true,
      ["sign", "verify"]
    );
  }

  function saltnumToUint8Array(num) {
  let arr = new Uint8Array(16);

  for (let i = 0; i < 16; i++) {
    arr[i] = num % 256;
    num = Math.floor(num / 256);
  }

  return arr;
}

function ivnumToUint8Array(num) {
  let arr = new Uint8Array(12);

  for (let i = 0; i < 16; i++) {
    arr[i] = num % 256;
    num = Math.floor(num / 256);
  }

  return arr;
}

async function generate_secret_key(otherPublicKey){
    console.log(otherPublicKey);
  const publicKey = await window.crypto.subtle.importKey(
    "jwk",
    JSON.parse(otherPublicKey.replaceAll("\'", "\"").replace("True","true")),
    {
      name: "ECDH",
      namedCurve: "P-384",
    },
    true,
    []
  );
    await deriveSharedSecret(
      myKeyPair.privateKey,
      publicKey
    );

}

async function generateKey() {
    myKeyPair = await window.crypto.subtle.generateKey(
    {
      name: "ECDH",
      namedCurve: "P-384",
    },
    true,
    ["deriveBits","deriveBits"],
  );
  console.log(myKeyPair);
  myExportPublicKey = await window.crypto.subtle.exportKey(
    "jwk",
    myKeyPair.publicKey);
    console.log(myExportPublicKey);
}


  async function deriveSharedSecret(privateKey, publicKey) {
    const secret = await window.crypto.subtle.deriveBits(
        // NOT SURE 384
      { name: "ECDH", 
      public: publicKey },
      privateKey,
      384
    );
    const buffer = new Uint8Array(secret, 0, 48);
    content = `${buffer}…[${secret.byteLength} bytes total]`;
    console.log(content)
    // console.log(secret)
    let str = getArrayBufferString(secret);
    localStorage.setItem("secretbits_"+peer_id.toString(),str);
    localStorage.setItem("secret_bits_counter_"+peer_id.toString(),0);
  }

  function get_shared_secret_key(){
    let secretfromstorage = parseArrayBufferString(localStorage.getItem("secretbits_"+peer_id.toString()));
    // let strst = localStorage.getItem("secretbits");
    
    // console.log(secretfromstorage);
    const buffer2 = new Uint8Array(secretfromstorage,0,48);
    content2 = `${buffer2}…[${secretfromstorage.byteLength} bytes total]`;
    console.log(content2)

    return window.crypto.subtle.importKey(
      "raw",
      secretfromstorage,
      { name: "HKDF" },
      false,
      ["deriveKey"]
    );
  }

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Refresh Keys function placeholder
function refreshKeys() {
    console.log('Refresh keys functionality will be implemented here.');
    // Placeholder for refresh functionality
    generate_edmac_key_user1();
    sendRefreshKeyinit();

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

async function encryptMessage(message) {
    console.log(message);
    const encoded = await getMessageEncoding(message);
    console.log(getArrayBufferString(encoded));
    let counter = JSON.parse(localStorage.getItem('secret_bits_counter_'+peer_id.toString()));
    let key = await get_enc_dec_Key("CHAT_KEY_USER"+myID.toString()+"to"+peer_id.toString()+"_"+counter.toString());
    // iv will be needed for decryption
    let count = await JSON.parse(localStorage.getItem("encryption_iv_"+peer_id.toString()+"_"+counter.toString()))+1;
    const iv = await ivnumToUint8Array(count);
    console.log(iv);
    ciphertext = await window.crypto.subtle.encrypt(
        { name: "AES-GCM", 
        iv: iv,
        additionalData: parseArrayBufferString("CHAT_MSG_USER"+myID.toString+"to"+peer_id.toString())},
        key,
        encoded,
    );
    // the cipher text is length of plain text + 16 bytes 
    localStorage.setItem("encryption_iv_"+peer_id.toString()+"_"+counter.toString(), JSON.stringify(count));
    let buffer = new Uint8Array(ciphertext, 0, 5);
    console.log("cyphertext value "+ `${buffer}...[${ciphertext.byteLength} bytes total]`);
    console.log("type of ciphertect ",typeof ciphertext);
    console.log(getArrayBufferString(ciphertext));
    // console.log(typeof getArrayBufferString(ciphertext));
    return getArrayBufferString(ciphertext);

}



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /*
  Fetch the ciphertext and decrypt it.
  Write the decrypted message into the "Decrypted" box.
  */
 // sender side
  async function decryptMessage(message) {
    
    let valid = await verifyMessage(message);
    if (!valid){
      window.alert("signature invalid!")
      return "";
    }
    let counter = message.message_secret_counter;
    let ivnum = Number(message.message_iv);
    if (message.sender_id==myID.toString()){
      const last_iv = JSON.parse(localStorage.getItem("decryption_iv_"+myID.toString()+"to"+peer_id.toString()+"_"+counter));
      if (last_iv>=ivnum){
        windows.alert("iv not valid");
      }
      localStorage.setItem("decryption_iv_"+myID.toString()+"to"+peer_id.toString()+"_"+counter, JSON.stringify(ivnum));
    }
    if (message.sender_id==peer_id.toString()){
      const last_iv = JSON.parse(localStorage.getItem("decryption_iv_"+peer_id.toString()+"to"+myID.toString()+"_"+counter));
      if (last_iv>=ivnum){
        windows.alert("iv not valid");
      }
      localStorage.setItem("decryption_iv_"+peer_id.toString()+"to"+myID.toString()+"_"+counter, JSON.stringify(ivnum));
    }
    let key = await get_enc_dec_Key("CHAT_KEY_USER"+message.sender_id.toString()+"to"+message.receiver_id.toString()+"_"+counter);
    const iv = await ivnumToUint8Array(ivnum);
    console.log(iv);
    let array_buffer = await parseArrayBufferString(message.message_text);
    console.log(getArrayBufferString(array_buffer));
    let decrypted = await window.crypto.subtle.decrypt(
      {
        name: "AES-GCM",
        iv: iv,
        additionalData: parseArrayBufferString("CHAT_KEY_USER"+myID.toString+"to"+peer_id.toString()),
      },
      key,
      array_buffer
    );
    console.log(decrypted);

    let dec = new TextDecoder();
    decrypted_msg= await dec.decode(decrypted);
    console.log(decrypted_msg);
    console.log(typeof decrypted_msg);
    return decrypted_msg;

  }

  /*
  Fetch the encoded message-to-sign and verify it against the stored signature.
  * If it checks out, set the "valid" class on the signature.
  * Otherwise set the "invalid" class.
  */
  async function verifyMessage(message) {
    const signatureValue = message.message_tag;
    console.log(signatureValue);
    let signature_array = parseArrayBufferString(signatureValue);
    let count = Number(message.message_iv);
    const iv = await ivnumToUint8Array(count);
    let iv_str = getArrayBufferString(iv);
    let encoded = getMessageEncoding(iv_str);
    let counter = message.message_secret_counter;
    let key = await get_mac("CHAT_MAC_USER"+message.sender_id.toString()+"to"+message.receiver_id.toString()+"_"+counter.toString());

    let result = await window.crypto.subtle.verify(
      "HMAC",
      key,
      signature_array,
      encoded
    );

    console.log(result);
    console.log(typeof result);
    return result;
  }

  function get_enc_dec_Key(name){
    let keystr = localStorage.getItem(name);
    let array_buffer = parseArrayBufferString(keystr);
    return window.crypto.subtle.importKey(
      "raw",
      array_buffer,
      { name: "AES-GCM" },
      false,
      ["encrypt","decrypt"]
    );
}

  ////////////////////////////////////////////////////////////////////////////////////////////////////
function get_mac(name){
  jwk = JSON.parse(localStorage.getItem(name));
  return window.crypto.subtle.importKey(
    "jwk",
    jwk,
    {
      name: "HMAC",
      hash: "SHA-256",
      length: 256
    },
    true,
    ["sign", "verify"],
  );

}




async function signiv(){
  let counter = JSON.parse(localStorage.getItem('secret_bits_counter_'+peer_id.toString()));
  let count = JSON.parse(localStorage.getItem("encryption_iv_"+peer_id.toString()+"_"+counter.toString()));
  const iv = await ivnumToUint8Array(count);
  let iv_str = getArrayBufferString(iv);
  let encoded = getMessageEncoding(iv_str);
  let key = await get_mac("CHAT_MAC_USER"+myID.toString()+"to"+peer_id.toString()+"_"+counter.toString());
  let signature = await window.crypto.subtle.sign("HMAC", key, encoded);
  let signstr = getArrayBufferString(signature);
  console.log("signature:")
  console.log(signstr);
  console.log(typeof signature);
  return signstr;
  

}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


function getMessageEncoding(message0) {
    const message = message0;
    const enc = new TextEncoder();
    return enc.encode(message);
    }

  function getArrayBufferString(arrayBuffer){
    return new Uint8Array(arrayBuffer).toString()
  }
  function parseArrayBufferString(string){
    return new Uint8Array(string.split(',')).buffer
  }

  function arrayBufferToBase64( buffer ) {
    var binary = '';
    var bytes = new Uint8Array( buffer );
    var len = bytes.byteLength;
    for (var i = 0; i < len; i++) {
        binary += String.fromCharCode( bytes[ i ] );
    }
    return window.btoa( binary );
}


</script>
</body>
</html>
