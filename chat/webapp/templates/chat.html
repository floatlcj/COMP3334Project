<!DOCTYPE html>
<html lang="en">
<!-- 
This software is provided under the BSD License. Copyright (c) 2024 Xavier de Carné de Carnavalet.
Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the original author is acknowledged. See JavaScript source for full license text.
-->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat Application</title>
    <!-- Bootstrap CSS for styling -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <!-- Custom CSS -->
    <link href="{{ url_for('static', filename='styles.css') }}" rel="stylesheet">
    <!-- <script type = "text/javascript" src="generateKeyPair.js"></script> -->
</head>
<body>
<div class="container mt-4">
    <h2>Chat Application <small> - (<a href="/logout">Logout</a>)</small></h2>
    <div class="chat-box">
        <!-- Chat messages container -->
        <div id="messages" style="border:1px solid #ccc; height:300px; margin-bottom:20px; overflow-y:scroll; padding:10px;"></div>
        <!-- User selection dropdown -->
        <select id="userList" class="form-control mb-2">
            <option value="-1" disabled selected><i>Choose a contact</i></option>
            <!-- User options populated here -->
        </select>
        <!-- Message input -->
        <textarea id="messageInput" class="form-control mb-2" placeholder="Type a message..."></textarea>
        <div class="d-flex justify-content-between">
            <button onclick="sendInputMessage()" class="btn btn-primary">Send</button>
            <button onclick="initial_ECDH()" class="btn btn-primary">generateKeyEC</button>
            <div>
                <button onclick="refreshKeys()" class="btn btn-secondary btn-sm">Refresh Keys</button>
                <button onclick="eraseChat()" class="btn btn-danger btn-sm">Erase Chat</button>
            </div>
        </div>
    </div>
</div>

<!-- jQuery for simplified JavaScript -->
<script src="https://code.jquery.com/jquery-3.7.1.min.js" integrity="sha384-1H217gwSVyLSIfaLxHbE7dRb3v4mYCKbpQvzx0cegeju1MVsGrX5xXxAvs/HgeFs" crossorigin="anonymous"></script>
<script type="text/javascript">

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Global variables
let lastMessageId = 0;
let peer_id = -1;
const myID = {{ sender_id }};
let userInfo = {};
let myKeyPair;
let otherPublicKey;
let mySecretKey;
let myExportPublicKey;
let myExportPublicKey_time;
let lastMessage;
let last_finished;

var decryption_iv_me_to_peer;
var decryption_iv_peer_to_me;
let s_secret;
let c_keyset;
let older;
// let first = 0;

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Ctrl+Enter to send message
document.addEventListener('DOMContentLoaded', function() {
    document.getElementById('messageInput').addEventListener('keydown', function(e) {
        if (e.ctrlKey && e.key === 'Enter') {
            sendMessage();
        }
    });
});

function sendInputMessage(){
    sendMessage("normal");
}
function sendECDH_request(){
    sendMessage("ECDH request");
}
function sendECDH_response(){
    sendMessage("ECDH response");
    // myExportPublicKey == null;
}
function sendRefreshKeyinit(){
  sendMessage("refresh key");
}
function sendRefreshKeyreply(){
  sendMessage("refresh key reply");
}
function sendEraseChat(){
  sendMessage("erase chat");
}

// Send message function
async function sendMessage(type) {
    if (peer_id == -1) return; // Exit if no peer selected
    let message0,message;
    let status = 'n';
    let value = '';
    let tag = '';
    let iv = '';
    let counter = '';
    if (type=='normal' ) {
        secret_counter = JSON.parse(localStorage.getItem('secret_counter_USER'+peer_id.toString())).toString();
        counter = JSON.parse(localStorage.getItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString())).toString();
        
        message0 = document.getElementById('messageInput').value;
        message = await encryptMessage(message0, "CHAT_MSG_USER"+myID.toString+"to"+peer_id.toString());
        // message = message0;
        iv = (JSON.parse(localStorage.getItem("encryption_iv_USER"+peer_id.toString()+"_KEYSET"+counter.toString()+"_SECRET"+secret_counter.toString()))).toString();
        tag = await signiv(Number(counter),Number(secret_counter),"");
    }
    if (type=='refresh key reply' ) {
      // secret_counter = JSON.parse(localStorage.getItem('secret_counter_USER'+peer_id.toString())).toString();
      // counter = JSON.parse(localStorage.getItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString())).toString();
      
      message = "";
        // message0 = "Key changed";
        // message = await encryptMessage(message0, "CHAT_MSG_USER"+myID.toString+"to"+peer_id.toString());
        // message = message0;
        // iv = (JSON.parse(localStorage.getItem("encryption_iv_USER"+peer_id.toString()+"_KEYSET"+counter.toString()+"_SECRET"+secret_counter.toString()))).toString();
        // tag = await signiv(Number(counter),Number(secret_counter),"");
    }
    if (type=='ECDH request'||type=='ECDH response') {
        message0 = myExportPublicKey;
        message = message0;
    }
    if (type=='refresh key'){
      secret_counter = JSON.parse(localStorage.getItem('secret_counter_USER'+peer_id.toString())).toString();
      counter = JSON.parse(localStorage.getItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString())).toString();
      
        message = "";
        iv = (JSON.parse(localStorage.getItem("encryption_iv_USER"+peer_id.toString()+"_KEYSET"+(counter-1).toString()+"_SECRET"+secret_counter.toString()))).toString();
        tag = await signpreiv(counter, secret_counter,"change");
        // counter_previous = (counter).toString();
        // put the old mac signed iv into msg_value
        value = await signiv(counter-1, secret_counter, "change");
        counter = ""
        // iv = '';
    }
    if (type=='erase chat'){
      // secret_counter = JSON.parse(localStorage.getItem('secret_counter_USER'+peer_id.toString())).toString();
      // counter = JSON.parse(localStorage.getItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString())).toString();
      
        message = "";
      //   iv = (JSON.parse(localStorage.getItem("encryption_iv_USER"+peer_id.toString()+"_KEYSET"+(counter-1).toString()+"_SECRET"+secret_counter.toString()))).toString();
      //   tag = await signiv(Number(counter),Number(secret_counter),"");
      //   // counter_previous = (counter).toString();
      //   // put the old mac signed iv into msg_value
      //   // value = await signiv(counter-1, secret_counter, "erase");
      //   counter = ""
        // iv = '';
    }
    // const message = message0;
    const payload = {
        receiver_id: peer_id,
        message_text: message,
        message_type: type,
        message_iv: iv,
        message_value: value,
        message_tag: tag,
    };
    console.log("the message i sent");
    console.log(JSON.stringify(payload));

    fetch('/send_message', {
        method: 'POST', // Specify the method
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
    })
    .then(response => {
        if (!response.ok) {
            // If the server response is not OK, throw an error
            throw new Error('Network response was not ok');
        }
        return response.json(); // Parse JSON response from the server
    })
    .then(data => {
        console.log('Message sent:', data); // Log success message
        document.getElementById('messageInput').value = ''; // Clear the input after sending
    })
    .catch(error => {
        console.error('Error sending message:', error); // Log any errors
    });
}



// Populate users function
// document is the webpage. we define the id in the html. now we can get it
function populateUsers(users) {
    const userListDropdown = document.getElementById("userList");
    users.forEach(user => {
        const option = new Option(user[1], user[0]); // username as text, user_id as value
        userListDropdown.add(option);
    });
}

// Fetch users from server
$(document).ready(function() {
    fetch('/users')
        .then(response => response.json())
        .then(data => {
            data.users.forEach(user => {
                userInfo[user[0]] = user[1]; // Map user_id to username
            });
            console.log(userInfo);
            populateUsers(data.users);
        })
        .catch(error => console.error('Error fetching user info:', error));

});

// Handle user selection change
document.getElementById('userList').addEventListener('change', async(event) => {
    peer_id = parseInt(event.target.value, 10); // Convert selected peer_id to integer
    clearChatBox();
    lastMessageId = 0;
    older = true;
    // first = 0;
    if (localStorage.getItem("USER"+peer_id.toString())!=null){
      decryption_iv_me_to_peer = JSON.parse(localStorage.getItem("decryption_iv_START_USER"+myID.toString()+"to"+peer_id.toString()));
      decryption_iv_peer_to_me = JSON.parse(localStorage.getItem("decryption_iv_START_USER"+peer_id.toString()+"to"+myID.toString()));
      s_secret = JSON.parse(localStorage.getItem("secret_START_USER"+peer_id.toString()));
      c_keyset = JSON.parse(localStorage.getItem("keyset_START_USER"+peer_id.toString()));
    }
    await fetchMessages(); // Fetch messages for the new selection
    // older = false;
    // first = 1;
    console.log("finish fetch");
    if (localStorage.getItem("USER"+peer_id.toString())==null && myID<peer_id){
      console.log("init becaus of ls");
      await initial_ECDH();
      // localStorage.setItem("USER"+peer_id.toString(),0);
      setInterval(fetchMessages, 1000);
      delay();
      // setTimeout(delay, 65000);
    }
    else if (localStorage.getItem("USER"+peer_id.toString())==null && myID>peer_id){
      // wait for 1 seconds to catch init if there is
      await new Promise(resolve => setTimeout(resolve, 1000));
      await fetchMessages();
      console.log("after this fetch");
      setInterval(fetchMessages, 1000);
      setInterval(checklocalStorage, 65000);
    }else {
      setInterval(fetchMessages, 1000);
      setInterval(checklocalStorage, 65000);

    }
    // setInterval(fetchMessages, 1000);
    
});

function delay(){
  // a key exchange message is valid for 1min
  setInterval(checklocalStorage, 65000);
}

function test(){
  console.log("hello");
}

// Clear chat box
function clearChatBox() {
    document.getElementById('messages').innerHTML = '';
}

function checklocalStorage(){
  console.log("checklocalStorage");
  if (localStorage.getItem("USER"+peer_id.toString())==null){
      initial_ECDH();
      // localStorage.setItem("USER"+peer_id.toString(),0);
    }
}

// async function asyncForEach(callback) {
//   await for(let i = 0; i < this.length; i++) {
//     await callback(this[i], i, this);
//   }
// }

// Fetch messages from server
function fetchMessages() {
    if (peer_id === -1) return; // Exit if no peer selected
    fetch(`/fetch_messages?last_message_id=${lastMessageId}&peer_id=${peer_id}`)
        .then(response => response.json())
        .then( async(data) => {
          for (const message of data.messages) {
          //   await givePrizeToPlayer(player);
          // }
            // data.messages.asyncforEach(async(message) => {
                await displayMessage(message);
                console.log(message.created_at);
                lastMessageId = message.message_id;
                console.log(message.message_type);
                var diff = Date.now()-new Date(message.created_at).getTime();
                console.log(diff);
                var minutes = Math.floor((diff/1000)/60);
                console.log(minutes);
                if (message.message_type == "ECDH request" && message.sender_id == peer_id && minutes<1  ){
                    if (localStorage.getItem("USER"+peer_id.toString())==null){
                      localStorage.setItem("USER"+peer_id.toString(),0);
                      localStorage.setItem("last_response_USER"+peer_id.toString(),0);
                      localStorage.setItem("secret_START_USER"+peer_id.toString(),1);
                      // localStorage.setItem("time_START_USER"+peer_id.toString(),0);
                      localStorage.setItem("keyset_START_USER"+peer_id.toString(),1);
                      localStorage.setItem("decryption_iv_START_USER"+myID.toString()+"to"+peer_id.toString(),0);
                      localStorage.setItem("decryption_iv_START_USER"+peer_id.toString()+"to"+myID.toString(),0);
                      decryption_iv_me_to_peer = 0;
                      decryption_iv_peer_to_me = 0;
                      s_secret = 1;
                      c_keyset = 1;
                    }
                    last_res = JSON.parse(localStorage.getItem("last_response_USER"+peer_id.toString()));
                    if (new Date(message.created_at).getTime()>last_res){
                      localStorage.setItem("last_response_USER"+peer_id.toString(),(new Date(message.created_at).getTime()).toString());
                      reply_to_ECDH(message.message_text);
                     }
                    
                }
                if (message.message_type=='ECDH response' && message.sender_id == peer_id && minutes<1){
                  if (localStorage.getItem("last_response_USER"+peer_id.toString())==null){
                    localStorage.setItem("last_response_USER"+peer_id.toString(),0)
                  }
                  last_res = JSON.parse(localStorage.getItem("last_response_USER"+peer_id.toString()));
                    if (new Date(message.created_at).getTime()>last_res){
                      localStorage.setItem("last_response_USER"+peer_id.toString(),(new Date(message.created_at).getTime()).toString());
                      receive_ECDH_response(message.message_text);
                      
                    }
                }
                if (message.message_type=='refresh key' && message.sender_id == peer_id && minutes<1){
                  last_res = JSON.parse(localStorage.getItem("last_response_USER"+peer_id.toString()));
                    if (new Date(message.created_at).getTime()>last_res){
                      localStorage.setItem("last_response_USER"+peer_id.toString(),(new Date(message.created_at).getTime()).toString());
                      console.log((new Date(message.created_at).getTime()).toString())
                      reply_to_key_refresh(message);
                      
                    }
                }
                if (message.message_type == 'erase chat' && message.sender_id == peer_id){
                  last_res = JSON.parse(localStorage.getItem("last_response_USER"+peer_id.toString()));
                  if (new Date(message.created_at).getTime()>last_res){
                      localStorage.setItem("last_response_USER"+peer_id.toString(),(new Date(message.created_at).getTime()).toString());
                      console.log((new Date(message.created_at).getTime()).toString())
                      reply_to_erase_chat(message);
                      
                    }
                }
            };
        })
        .catch(error => console.error('Error fetching messages:', error));
    console.log("fetch message");
}

// Display a single message
async function displayMessage(message) {
  // try{
    const messagesContainer = document.getElementById('messages');
    const messageElement = document.createElement('div');

    // Determine sender and receiver strings
    const sender = message.sender_id == myID ? "me" : (userInfo[message.sender_id] || `User ${message.sender_id}`);
    const receiver = message.receiver_id == myID ? "me" : (userInfo[message.receiver_id] || `User ${message.receiver_id}`);
    console.log("this");
    if (message.message_type=="normal"){
      console.log("sadd");
      let text;
      last_res = JSON.parse(localStorage.getItem("last_response_USER"+peer_id.toString()));
      if (last_res>=new Date(message.created_at).getTime() && older == true){
        console.log("aaa");
        text = await decryptolderMessage(message);
      }else {
        text = await decryptMessage(message);
        console.log("bbb");
        localStorage.setItem("last_response_USER"+peer_id.toString(),(new Date(message.created_at).getTime()).toString());
      }
      
      // if (older == true){
      //   text = await decryptolderMessage(message);
      // }else {
      //   text = await decryptMessage(message);
      // }
      messageElement.textContent = `From ${sender} to ${receiver}: ${text}`;
      // console.log("message:",messageElement.textContent);
    }else if (message.message_type=="refresh key reply"){
      messageElement.textContent = `From ${sender} to ${receiver}: ${"Keys changed"}`;
    }
    else if (message.message_type=="refresh key"){
      messageElement.textContent = "Keys changed";
    }else if (message.message_type == "ECDH request" ){
      messageElement.textContent = `From ${sender} to ${receiver}: ${"ECDH request"}`;
    }else if (message.message_type == "ECDH response" ){
      messageElement.textContent = `From ${sender} to ${receiver}: ${"ECDH response"}`;
    }else if (message.message_type == "erase chat"){
      messageElement.textContent = "";
    }
    else {
      messageElement.textContent = `From ${sender} to ${receiver}: ${message.message_text}`;
    }
    // messageElement.textContent = `From ${sender} to ${receiver}: ${message.message_text}`;
    // console.log(messageElement.textContent);
    messagesContainer.appendChild(messageElement);
//   }catch(e) {
//     console.log(e.name, e.message);
// }
  // }
  


}

// console.log("already set interval");
// Periodically fetch new messages every second
// setInterval(fetchMessages, 1000);
// setInterval(checklocalStorage,2000);

// Erase Chat function using fetch API
function eraseChat() {
    if (peer_id === -1) return; // Exit if no peer selected
    if (!confirm('Are you sure you want to erase the chat with '+userInfo[peer_id]+'?')) return; // Confirmation before erasing
    if (localStorage.getItem("USER"+peer_id.toString())!=null){
      // localStorage.setItem("time_START_USER"+peer_id.toString(),0);
      let s = JSON.parse(localStorage.getItem("secret_counter_USER"+peer_id.toString()));
      localStorage.setItem("secret_START_USER"+peer_id.toString(),JSON.stringify(s));
      let c = JSON.parse(localStorage.getItem("keyset_counter_USER"+peer_id.toString()+"_SECRET"+s.toString()));
      localStorage.setItem("keyset_START_USER"+peer_id.toString(),JSON.stringify(c));
      let dmtp = JSON.parse(localStorage.getItem("decryption_iv_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+c.toString()+"_SECRET"+s.toString()));
      localStorage.setItem("decryption_iv_START_USER"+myID.toString()+"to"+peer_id.toString(),JSON.stringify(dmtp));
      let dptm = JSON.parse(localStorage.getItem("decryption_iv_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+c.toString()+"_SECRET"+s.toString()));
      localStorage.setItem("decryption_iv_START_USER"+peer_id.toString()+"to"+myID.toString(),JSON.stringify(dptm));
    }

    fetch(`/erase_chat`, {
        method: 'POST',  // A REST API should use POST if it leads to modifications
        headers: {
            'Content-Type': 'application/json', 
        },
        body: JSON.stringify({ peer_id: peer_id })
    })
    .then(response => {
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        return response.json(); // Assuming the server responds with JSON
    })
    .then(data => {
        console.log('Chat erased:', data);
        clearChatBox(); // Clear the chat display
    })
    .catch(error => {
        console.error('Error erasing chat:', error);
    });

    sendEraseChat();
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

async function initial_ECDH(){
    await generateKey();
    sendECDH_request();
}

async function receive_ECDH_response(otherpublickey){
    await generate_secret_key(otherpublickey);
    await generate_edmac_key_user1();
    localStorage.setItem("USER"+peer_id.toString(),0);
    // localStorage.setItem("last_response_USER"+peer_id.toString(),0);
    localStorage.setItem("secret_START_USER"+peer_id.toString(),1);
    // localStorage.setItem("time_START_USER"+peer_id.toString(),0);
    localStorage.setItem("keyset_START_USER"+peer_id.toString(),1);
    localStorage.setItem("decryption_iv_START_USER"+myID.toString()+"to"+peer_id.toString(),0);
    localStorage.setItem("decryption_iv_START_USER"+peer_id.toString()+"to"+myID.toString(),0);
    
    decryption_iv_me_to_peer = 0;
    decryption_iv_peer_to_me = 0;
    s_secret = 1;
    c_keyset = 1;
}

async function reply_to_ECDH(otherpublickey){
  // if (myExportPublicKey == null){
    await generateKey();
    await sendECDH_response();
    await generate_secret_key(otherpublickey);
    await generate_edmac_key_user2();
    // myExportPublicKey == null;
  // }else {
  //   await generate_secret_key(otherpublickey);
  //   if (myID>peer_id){
  //     generate_edmac_key_user2();
  //   }else {
  //     await generate_edmac_key_user1();
  //   }
  //   myExportPublicKey ==null;
  // }



}

async function generate_edmac_key_user1(){
    let keyMaterial =await get_shared_secret_key();
    console.log(typeof keyMaterial);
    console.log(keyMaterial);
    let secret_counter = JSON.parse(localStorage.getItem('secret_counter_USER'+peer_id.toString())).toString();
    let count = JSON.parse(localStorage.getItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString()))+1;
    localStorage.setItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString(), JSON.stringify(count));
    let encryption = await getKey(keyMaterial, 2*count-1, "CHAT_KEY_"+myID+"to"+peer_id.toString());
    let decryption = await getKey(keyMaterial, 2*count, "CHAT_KEY_"+peer_id.toString()+"to"+myID);
    console.log(encryption);
    console.log(decryption);

    // buffer array
    const encryption_exported = await window.crypto.subtle.exportKey("raw",encryption);
    let encryption_str = getArrayBufferString(encryption_exported);
    localStorage.setItem("CHAT_KEY_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),encryption_str);
    const decryption_exported = await window.crypto.subtle.exportKey("raw",decryption);
    let decryption_str = getArrayBufferString(decryption_exported);
    localStorage.setItem("CHAT_KEY_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),decryption_str);
    localStorage.setItem("encryption_iv_USER"+peer_id.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),0);
    localStorage.setItem("decryption_iv_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),0);
    localStorage.setItem("decryption_iv_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),0);

    let mac_me = await getmacKey(keyMaterial, 2*count-1, "CHAT_MAC_"+myID.toString()+"to"+peer_id.toString());
    let mac_other = await getmacKey(keyMaterial, 2*count, "CHAT_MAC_"+peer_id.toString()+"to"+myID.toString());
    console.log(mac_me);
    console.log(mac_other);
    
    mac_me_exported = await window.crypto.subtle.exportKey("jwk",mac_me);
    // console.log(typeof mac_me_exported);
    localStorage.setItem("CHAT_MAC_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),JSON.stringify(mac_me_exported));
    mac_other_exported = await window.crypto.subtle.exportKey("jwk",mac_other);
    localStorage.setItem("CHAT_MAC_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),JSON.stringify(mac_other_exported));


}

async function generate_edmac_key_user2(){
    let keyMaterial =await get_shared_secret_key();
    console.log(typeof keyMaterial);
    console.log(keyMaterial);
    let secret_counter = JSON.parse(localStorage.getItem('secret_counter_USER'+peer_id.toString())).toString();
    let count = JSON.parse(localStorage.getItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString()))+1;
    localStorage.setItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString(), JSON.stringify(count));
    let decryption = await getKey(keyMaterial, 2*count-1, "CHAT_KEY_"+myID.toString()+"to"+peer_id.toString());
    let encryption = await getKey(keyMaterial, 2*count, "CHAT_KEY_"+peer_id.toString()+"to"+myID.toString());
    
    const encryption_exported = await window.crypto.subtle.exportKey("raw",encryption);
    let encryption_str = getArrayBufferString(encryption_exported);
    localStorage.setItem("CHAT_KEY_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),encryption_str);
    const decryption_exported = await window.crypto.subtle.exportKey("raw",decryption);
    let decryption_str = getArrayBufferString(decryption_exported);
    localStorage.setItem("CHAT_KEY_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),decryption_str);
    localStorage.setItem("encryption_iv_USER"+peer_id.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),0);
    localStorage.setItem("decryption_iv_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),0);
    localStorage.setItem("decryption_iv_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),0);

    let mac_other = await getmacKey(keyMaterial, 2*count-1, "CHAT_MAC_"+peer_id.toString()+"to"+myID.toString());
    let mac_me = await getmacKey(keyMaterial, 2*count, "CHAT_MAC_"+myID.toString()+"to"+peer_id.toString());
    console.log(mac_me);
    console.log(mac_other);

    mac_me_exported = await window.crypto.subtle.exportKey("jwk",mac_me);
    // console.log(typeof mac_me_exported);
    localStorage.setItem("CHAT_MAC_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),JSON.stringify(mac_me_exported));
    mac_other_exported = await window.crypto.subtle.exportKey("jwk",mac_other);
    localStorage.setItem("CHAT_MAC_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),JSON.stringify(mac_other_exported));
}

  /*
  Given some key material and some random salt,
  derive an AES-GCM key using HKDF.
  */
  function getKey(keyMaterial, saltnum, information) {
    return window.crypto.subtle.deriveKey(
      {
        name: "HKDF",
        salt: saltnumToUint8Array(saltnum),
        info: new Uint8Array(information),
        hash: "SHA-256",
      },
      keyMaterial,
      { name: "AES-GCM", length: 256 },
      true,
      ["encrypt", "decrypt"]
    );
  }
  
  function getmacKey(keyMaterial, saltnum, information) {
    return window.crypto.subtle.deriveKey(
      {
        name: "HKDF",
        salt: saltnumToUint8Array(saltnum),
        info: new Uint8Array(information),
        hash: "SHA-256",
      },
      keyMaterial,
      { name: "HMAC", 
        hash: "SHA-256",
        length: 256 },
      true,
      ["sign", "verify"]
    );
  }

  function saltnumToUint8Array(num) {
  let arr = new Uint8Array(16);

  for (let i = 0; i < 16; i++) {
    arr[i] = num % 256;
    num = Math.floor(num / 256);
  }

  return arr;
}

function ivnumToUint8Array(num) {
  let arr = new Uint8Array(12);

  for (let i = 0; i < 16; i++) {
    arr[i] = num % 256;
    num = Math.floor(num / 256);
  }

  return arr;
}

async function generate_secret_key(otherPublicKey){


    console.log(otherPublicKey);
  const publicKey = await window.crypto.subtle.importKey(
    "jwk",
    JSON.parse(otherPublicKey.replaceAll("\'", "\"").replace("True","true")),
    {
      name: "ECDH",
      namedCurve: "P-384",
    },
    true,
    []
  );
    await deriveSharedSecret(
      myKeyPair.privateKey,
      publicKey
    );

}

async function generateKey() {
    myKeyPair = await window.crypto.subtle.generateKey(
    {
      name: "ECDH",
      namedCurve: "P-384",
    },
    true,
    ["deriveBits","deriveBits"],
  );
  console.log(myKeyPair);
  myExportPublicKey = await window.crypto.subtle.exportKey(
    "jwk",
    myKeyPair.publicKey);
    console.log(myExportPublicKey);
  // myExportPublicKey_time = 
}


  async function deriveSharedSecret(privateKey, publicKey) {
    if (localStorage.getItem("secret_counter_USER"+peer_id.toString()) == null) {
      counter = 0;
    }else {
      counter = JSON.parse(localStorage.getItem("secret_counter_USER"+peer_id.toString()));
    }
    const secret = await window.crypto.subtle.deriveBits(
        // NOT SURE 384
      { name: "ECDH", 
      public: publicKey },
      privateKey,
      384
    );
    const buffer = new Uint8Array(secret, 0, 48);
    content = `${buffer}…[${secret.byteLength} bytes total]`;
    console.log(content)
    // console.log(secret)
    let str = getArrayBufferString(secret);
    localStorage.setItem("secretbits_USER"+peer_id.toString()+"_COUNTER"+(counter+1).toString(),str);
    localStorage.setItem("keyset_counter_USER"+peer_id.toString()+"_SECRET"+(counter+1).toString(),0);
    localStorage.setItem("secret_counter_USER"+peer_id.toString(),JSON.stringify(counter+1));
  }

  function get_shared_secret_key(){
    
    let counter = JSON.parse(localStorage.getItem("secret_counter_USER"+peer_id.toString()));
    let secretfromstorage = parseArrayBufferString(localStorage.getItem("secretbits_USER"+peer_id.toString()+"_COUNTER"+counter.toString()));
    
    // console.log(secretfromstorage);
    const buffer2 = new Uint8Array(secretfromstorage,0,48);
    content2 = `${buffer2}…[${secretfromstorage.byteLength} bytes total]`;
    console.log(content2)

    return window.crypto.subtle.importKey(
      "raw",
      secretfromstorage,
      { name: "HKDF" },
      false,
      ["deriveKey"]
    );
  }

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Refresh Keys function placeholder
async function refreshKeys() {
    console.log('Refresh keys functionality will be implemented here.');
    // Placeholder for refresh functionality
    await generate_edmac_key_user1();
    await sendRefreshKeyinit();
}

async function reply_to_key_refresh(message){
  console.log('Receive information to refresh keys');
  result = await verifyOldMac(message, "change");
  if (result==false ){
    window.alert("invalid old mac");
    return;
  }
  result2 = await verifyNewMac(message, "change");
  if (result2 == false){
    window.alert("invalid new mac");
    return;
  }
  await generate_edmac_key_user2();
  // sendRefreshKeyreply()

}

async function reply_to_erase_chat(message){
  console.log('Receive information to erase chat');
  // let secret_counter = JSON.parse(localStorage.getItem("secret_counter_USER"+peer_id.toString()));
  // let counter = JSON.parse(localStorage.getItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString()));

  // result = await verifyMessage(message, secret_counter, counter );
  // if (result==false ){
  //   console.log("test");
  //   window.alert("ERROR: invalid mac in erase chat");
  //   return;
  // }
  // result2 = await verifyNewMac(message, "erase");
  // if (result2 == false){
  //   window.alert("invalid new mac");
  //   return;
  // }
  if (localStorage.getItem("USER"+peer_id.toString())!=null){
      // localStorage.setItem("time_START_USER"+peer_id.toString(),0);
      let s = JSON.parse(localStorage.getItem("secret_counter_USER"+peer_id.toString()));
      localStorage.setItem("secret_START_USER"+peer_id.toString(),JSON.stringify(s));
      let c = JSON.parse(localStorage.getItem("keyset_counter_USER"+peer_id.toString()+"_SECRET"+s.toString()));
      localStorage.setItem("keyset_START_USER"+peer_id.toString(),JSON.stringify(c));
      let dmtp = JSON.parse(localStorage.getItem("decryption_iv_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+c.toString()+"_SECRET"+s.toString()));
      localStorage.setItem("decryption_iv_START_USER"+myID.toString()+"to"+peer_id.toString(),JSON.stringify(dmtp));
      let dptm = JSON.parse(localStorage.getItem("decryption_iv_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+c.toString()+"_SECRET"+s.toString()));
      localStorage.setItem("decryption_iv_START_USER"+peer_id.toString()+"to"+myID.toString(),JSON.stringify(dptm));
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

async function encryptMessage(message, additional) {
    console.log(message);
    const encoded = await getMessageEncoding(message);
    console.log(getArrayBufferString(encoded));
    let secret_counter = JSON.parse(localStorage.getItem("secret_counter_USER"+peer_id.toString()));
    let counter = JSON.parse(localStorage.getItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString()));
    let key = await get_enc_dec_Key("CHAT_KEY_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+counter.toString()+"_SECRET"+secret_counter.toString());
    // iv will be needed for decryption
    let count = await JSON.parse(localStorage.getItem("encryption_iv_USER"+peer_id.toString()+"_KEYSET"+counter.toString()+"_SECRET"+secret_counter.toString()))+1;
    const iv = await ivnumToUint8Array(count);
    console.log(iv);
    ciphertext = await window.crypto.subtle.encrypt(
        { name: "AES-GCM", 
        iv: iv,
        additionalData: parseArrayBufferString(additional)},
        key,
        encoded,
    );
    // the cipher text is length of plain text + 16 bytes 
    localStorage.setItem("encryption_iv_USER"+peer_id.toString()+"_KEYSET"+counter.toString()+"_SECRET"+secret_counter.toString(), JSON.stringify(count));
    let buffer = new Uint8Array(ciphertext, 0, 5);
    console.log("cyphertext value "+ `${buffer}...[${ciphertext.byteLength} bytes total]`);
    console.log("type of ciphertect ",typeof ciphertext);
    console.log(getArrayBufferString(ciphertext));
    // console.log(typeof getArrayBufferString(ciphertext));
    return getArrayBufferString(ciphertext);

}

async function encrypt_changeKey_Message(message){

}



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /*
  Fetch the ciphertext and decrypt it.
  Write the decrypted message into the "Decrypted" box.
  */
 // sender side
 // first == 0 
  async function decryptolderMessage(message) {
    console.log("older message");
    let last_iv;
    if (older ==true && localStorage.getItem("USER"+peer_id.toString())==null ){
      window.alert("local storage cleared");
      return "ERROR: local storage cleared";
    }
    // if (first == 0 && older == false){
    //   window.alert("CAN NOT DECRYPT");
    //   return "ERROR: can not decrypt";
    // }
    let secret_counter = JSON.parse(localStorage.getItem("secret_counter_USER"+peer_id.toString()));
    let counter = JSON.parse(localStorage.getItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString()));
    if (message.sender_id == myID.toString()){
      last_iv = decryption_iv_me_to_peer;
    }else {
      last_iv = decryption_iv_peer_to_me;
    }
    console.log("keyset", c_keyset);
    console.log("secret",s_secret);
    m2p = JSON.parse(localStorage.getItem("decryption_iv_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+c_keyset+"_SECRET"+s_secret));
    p2m = JSON.parse(localStorage.getItem("decryption_iv_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+c_keyset+"_SECRET"+s_secret));
    console.log(p2m);
    console.log(m2p);
    console.log("decryption_iv_me_to_peer",decryption_iv_me_to_peer);
    console.log("decryption_iv_peer_to_me",decryption_iv_peer_to_me);
      if (s_secret == secret_counter && c_keyset == counter){
        if (m2p == decryption_iv_me_to_peer && p2m == decryption_iv_peer_to_me){
          older=false;
          console.log("old messages finished.");
          return decryptMessage(message);
        }
      }
      else if (s_secret == secret_counter){
        console.log(decryption_iv_me_to_peer);
        console.log(decryption_iv_peer_to_me);
        if (decryption_iv_me_to_peer == m2p && decryption_iv_peer_to_me == p2m){
          console.log("this enter");
          c_keyset = c_keyset+1;
          decryption_iv_me_to_peer = 0;
          decryption_iv_peer_to_me = 0;
        }
      }else {
        c = JSON.parse(localStorage.getItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+s_secret.toString()));
        if (decryption_iv_me_to_peer = m2p && decryption_iv_peer_to_me == p2m && c==c_keyset){
          s_secret = s_secret+1;
          c_keyset = 1;
          decryption_iv_me_to_peer = 0;
          decryption_iv_peer_to_me = 0;
        }
      }
    
      secret_counter_used = s_secret;
      counter_used = c_keyset;
      if (message.sender_id == myID.toString()){
        console.log("1",decryption_iv_me_to_peer);
        last_iv = decryption_iv_me_to_peer;
        console.log("2",decryption_iv_me_to_peer);
      }else {
        last_iv = decryption_iv_peer_to_me;
      }
      

    console.log("secret_counter_used",secret_counter_used);
    console.log("counter_used",counter_used);
    let valid = await verifyMessage(message, secret_counter_used, counter_used);
    if (!valid){
      window.alert("signature invalid!")
      return "ERROR: signature invalid";
    }

    let ivnum = Number(message.message_iv);
    if (last_iv>=ivnum){
        window.alert("iv not valid");
        return "ERROR: invalid iv";
    }
    let key = await get_enc_dec_Key("CHAT_KEY_USER"+message.sender_id.toString()+"to"+message.receiver_id.toString()+"_KEYSET"+counter_used+"_SECRET"+secret_counter_used);
    const iv = await ivnumToUint8Array(ivnum);
    console.log(iv);
    let array_buffer = await parseArrayBufferString(message.message_text);
    console.log(getArrayBufferString(array_buffer));
    let decrypted;
    try{
      decrypted = await window.crypto.subtle.decrypt(
      {
        name: "AES-GCM",
        iv: iv,
        additionalData: parseArrayBufferString("CHAT_KEY_USER"+myID.toString+"to"+peer_id.toString()),
      },
      key,
      array_buffer
    );
    }catch(error){
      console.error(error);
      window.alert("decryption invalid!");
      return "ERROR: invalid decryption";
    }


      if (message.sender_id == myID.toString()){
        console.log("3",decryption_iv_me_to_peer);
        decryption_iv_me_to_peer = ivnum;
        console.log("4",decryption_iv_me_to_peer);
      }else {
        decryption_iv_peer_to_me = ivnum;
      }
    
        

    console.log(decrypted);
    let dec = new TextDecoder();
    decrypted_msg= await dec.decode(decrypted);
    console.log(decrypted_msg);
    console.log(typeof decrypted_msg);
    return decrypted_msg;

  }
  async function decryptMessage(message) {
    let secret_counter = JSON.parse(localStorage.getItem("secret_counter_USER"+peer_id.toString()));
    let counter = JSON.parse(localStorage.getItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString()));
    console.log("start encryption");
    console.log(message.message_id);
    let valid = await verifyMessage(message, secret_counter, counter);
    if (!valid){
      window.alert("signature invalid!");
      console.log("signature invalid");
      return "signature invalid";
    }
    // let counter = message.message_secret_counter;
    // TODO
    let ivnum = Number(message.message_iv);
    if (message.sender_id==myID.toString()){
      const last_iv = JSON.parse(localStorage.getItem("decryption_iv_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+counter+"_SECRET"+secret_counter));
      if (last_iv>=ivnum){
        window.alert("iv not valid");
        return "ERROR: invalid iv";
      }      
      localStorage.setItem("decryption_iv_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+counter+"_SECRET"+secret_counter, JSON.stringify(ivnum));
    }
    if (message.sender_id==peer_id.toString()){
      const last_iv = JSON.parse(localStorage.getItem("decryption_iv_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+counter+"_SECRET"+secret_counter));
      if (last_iv>=ivnum){
        window.alert("iv not valid");
        return "ERROR: invalid iv";
      }
      localStorage.setItem("decryption_iv_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+counter+"_SECRET"+secret_counter, JSON.stringify(ivnum));
    }
    let key = await get_enc_dec_Key("CHAT_KEY_USER"+message.sender_id.toString()+"to"+message.receiver_id.toString()+"_KEYSET"+counter+"_SECRET"+secret_counter);
    const iv = await ivnumToUint8Array(ivnum);
    console.log(iv);
    let array_buffer = await parseArrayBufferString(message.message_text);
    console.log(getArrayBufferString(array_buffer));
    let decrypted = await window.crypto.subtle.decrypt(
      {
        name: "AES-GCM",
        iv: iv,
        additionalData: parseArrayBufferString("CHAT_KEY_USER"+myID.toString+"to"+peer_id.toString()),
      },
      key,
      array_buffer
    );
    console.log(decrypted);

    let dec = new TextDecoder();
    decrypted_msg= await dec.decode(decrypted);
    console.log(decrypted_msg);
    console.log(typeof decrypted_msg);
    console.log("finish decryption");
    return decrypted_msg;

  }

  /*
  Fetch the encoded message-to-sign and verify it against the stored signature.
  * If it checks out, set the "valid" class on the signature.
  * Otherwise set the "invalid" class.
  */
  async function verifyMessage(message, secret_counter, counter) {
    const signatureValue = message.message_tag;
    console.log(signatureValue);
    let signature_array = parseArrayBufferString(signatureValue);
    let count = Number(message.message_iv);
    const iv = await ivnumToUint8Array(count);
    let iv_str = getArrayBufferString(iv);
    let encoded = getMessageEncoding(iv_str);
    // let counter = message.message_secret_counter;
    // TODO
    let key = await get_mac("CHAT_MAC_USER"+message.sender_id.toString()+"to"+message.receiver_id.toString()+"_KEYSET"+counter.toString()+"_SECRET"+secret_counter.toString());

    let result = await window.crypto.subtle.verify(
      "HMAC",
      key,
      signature_array,
      encoded
    );

    console.log(result);
    console.log(typeof result);
    return result;
  }

  async function verifyOldMac(message,str){
    const signatureValue = message.message_value;
    let signature_array = parseArrayBufferString(signatureValue);
    let secret_counter = JSON.parse(localStorage.getItem("secret_counter_USER"+peer_id.toString()));
    let counter = JSON.parse(localStorage.getItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString()));
    const last_iv = JSON.parse(localStorage.getItem("decryption_iv_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+counter+"_SECRET"+secret_counter));
    const iv = await ivnumToUint8Array(last_iv);
    let iv_str = getArrayBufferString(iv);
    let encoded = getMessageEncoding(iv_str+str);
    let key = await get_mac("CHAT_MAC_USER"+message.sender_id.toString()+"to"+message.receiver_id.toString()+"_KEYSET"+counter+"_SECRET"+secret_counter);
    let result = await window.crypto.subtle.verify(
      "HMAC",
      key,
      signature_array,
      encoded
    );

    console.log(result);
    console.log(typeof result);
    return result;
  }

  async function verifyNewMac(message,str){
    let keyMaterial =await get_shared_secret_key();
    let secret_counter = JSON.parse(localStorage.getItem("secret_counter_USER"+peer_id.toString()));
    let count = JSON.parse(localStorage.getItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString()))+1;

    let mac_other = await getmacKey(keyMaterial, 2*count-1, "CHAT_MAC_"+peer_id.toString()+"to"+myID.toString());
    console.log(mac_other);

    const signatureValue = message.message_tag;
    let signature_array = parseArrayBufferString(signatureValue);
    const last_iv = JSON.parse(localStorage.getItem("decryption_iv_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+(count-1).toString()+"_SECRET"+secret_counter));
    const iv = await ivnumToUint8Array(last_iv);
    let iv_str = getArrayBufferString(iv);
    let encoded = getMessageEncoding(iv_str+str);
    let result = await window.crypto.subtle.verify(
      "HMAC",
      mac_other,
      signature_array,
      encoded
    );

    console.log(result);
    console.log(typeof result);
    return result;


  }

  function get_enc_dec_Key(name){
    let keystr = localStorage.getItem(name);
    let array_buffer = parseArrayBufferString(keystr);
    return window.crypto.subtle.importKey(
      "raw",
      array_buffer,
      { name: "AES-GCM" },
      false,
      ["encrypt","decrypt"]
    );
}

  ////////////////////////////////////////////////////////////////////////////////////////////////////
function get_mac(name){
  jwk = JSON.parse(localStorage.getItem(name));
  return window.crypto.subtle.importKey(
    "jwk",
    jwk,
    {
      name: "HMAC",
      hash: "SHA-256",
      length: 256
    },
    true,
    ["sign", "verify"],
  );

}




// the mac and iv of same secret
async function signiv(counter, secret_counter, additional){
  // let counter = JSON.parse(localStorage.getItem('secret_bits_counter_'+peer_id.toString()));
  let count = JSON.parse(localStorage.getItem("encryption_iv_USER"+peer_id.toString()+"_KEYSET"+counter.toString()+"_SECRET"+secret_counter));
  const iv = await ivnumToUint8Array(count);
  let iv_str = getArrayBufferString(iv);
  let encoded = getMessageEncoding(iv_str+additional);
  let key = await get_mac("CHAT_MAC_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+counter.toString()+"_SECRET"+secret_counter);
  let signature = await window.crypto.subtle.sign("HMAC", key, encoded);
  let signstr = getArrayBufferString(signature);
  console.log("signature:")
  console.log(signstr);
  console.log(typeof signature);
  return signstr;

}

async function signpreiv(counter, secret_counter, additional){
  // let counter = JSON.parse(localStorage.getItem('secret_bits_counter_'+peer_id.toString()));
  let count = JSON.parse(localStorage.getItem("encryption_iv_USER"+peer_id.toString()+"_KEYSET"+(counter-1).toString()+"_SECRET"+secret_counter));
  const iv = await ivnumToUint8Array(count);
  let iv_str = getArrayBufferString(iv);
  let encoded = getMessageEncoding(iv_str+additional);
  let key = await get_mac("CHAT_MAC_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+counter.toString()+"_SECRET"+secret_counter);
  let signature = await window.crypto.subtle.sign("HMAC", key, encoded);
  let signstr = getArrayBufferString(signature);
  console.log("signature:")
  console.log(signstr);
  console.log(typeof signature);
  return signstr;

}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


function getMessageEncoding(message0) {
    const message = message0;
    const enc = new TextEncoder();
    return enc.encode(message);
    }

  function getArrayBufferString(arrayBuffer){
    return new Uint8Array(arrayBuffer).toString()
  }
  function parseArrayBufferString(string){
    return new Uint8Array(string.split(',')).buffer
  }

  function arrayBufferToBase64( buffer ) {
    var binary = '';
    var bytes = new Uint8Array( buffer );
    var len = bytes.byteLength;
    for (var i = 0; i < len; i++) {
        binary += String.fromCharCode( bytes[ i ] );
    }
    return window.btoa( binary );
}


</script>
</body>
</html>
