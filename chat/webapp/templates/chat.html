<!DOCTYPE html>
<html lang="en">
<!-- 
This software is provided under the BSD License. Copyright (c) 2024 Xavier de CarnÃ© de Carnavalet.
Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the original author is acknowledged. See JavaScript source for full license text.
-->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat Application</title>
    <!-- Bootstrap CSS for styling -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <!-- Custom CSS -->
    <link href="{{ url_for('static', filename='styles.css') }}" rel="stylesheet">
    <!-- <script type = "text/javascript" src="generateKeyPair.js"></script> -->
</head>
<body>
<div class="container mt-4">
    <h2>Chat Application <small> - (<a href="/logout">Logout</a>)</small></h2>
    <div class="chat-box">
        <!-- Chat messages container -->
        <div id="messages" style="border:1px solid #ccc; height:300px; margin-bottom:20px; overflow-y:scroll; padding:10px;"></div>
        <!-- User selection dropdown -->
        <select id="userList" class="form-control mb-2">
            <option value="-1" disabled selected><i>Choose a contact</i></option>
            <!-- User options populated here -->
        </select>
        <!-- Message input -->
        <textarea id="messageInput" class="form-control mb-2" placeholder="Type a message..."></textarea>
        <div class="d-flex justify-content-between">
            <button onclick="sendInputMessage()" class="btn btn-primary">Send</button>
            <button onclick="initial_ECDH()" class="btn btn-primary">generateKeyEC</button>
            <div>
                <button onclick="refreshKeys()" class="btn btn-secondary btn-sm">Refresh Keys</button>
                <button onclick="eraseChat()" class="btn btn-danger btn-sm">Erase Chat</button>
            </div>
        </div>
    </div>
</div>

<!-- jQuery for simplified JavaScript -->
<script src="https://code.jquery.com/jquery-3.7.1.min.js" integrity="sha384-1H217gwSVyLSIfaLxHbE7dRb3v4mYCKbpQvzx0cegeju1MVsGrX5xXxAvs/HgeFs" crossorigin="anonymous"></script>
<script type="text/javascript">

// Global variables
let lastMessageId = 0;
let peer_id = -1;
const myID = {{ sender_id }};
let userInfo = {};
let myKeyPair;
let otherPublicKey;
let mySecretKey;
let myExportPublicKey;
let myExportPrivateKey;
let ciphertext;

// Ctrl+Enter to send message
document.addEventListener('DOMContentLoaded', function() {
    document.getElementById('messageInput').addEventListener('keydown', function(e) {
        if (e.ctrlKey && e.key === 'Enter') {
            sendMessage();
        }
    });
});

function sendInputMessage(){
    sendMessage("normal");
}
function sendECDH_request(){
    sendMessage("ECDH request");
}
function sendECDH_response(){
    sendMessage("ECDH response");
}
// Send message function
async function sendMessage(type) {
    if (peer_id == -1) return; // Exit if no peer selected
    let message0;
    if (type=='normal') {
        let messageJs = await encrypt(document.getElementById('messageInput').value, mySecretKey);
        message0 = JSON.stringify(messageJs);
        console.log("message0", message0);
    }
    if (type=='ECDH request'||type=='ECDH response') message0 = JSON.stringify(myExportPublicKey);
    const message = message0;
    console.log("message", message);
    const payload = {
        receiver_id: peer_id,
        message_text: message,
        message_type: type,
    };
    console.log("payload", payload);

    fetch('/send_message', {
        method: 'POST', // Specify the method
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
    })
    .then(response => {
        if (!response.ok) {
            // If the server response is not OK, throw an error
            throw new Error('Network response was not ok');
        }
        return response.json(); // Parse JSON response from the server
    })
    .then(data => {
        console.log('Message sent:', data); // Log success message
        document.getElementById('messageInput').value = ''; // Clear the input after sending
    })
    .catch(error => {
        console.error('Error sending message:', error); // Log any errors
    });
}

// Refresh Keys function placeholder
function refreshKeys() {
    console.log('Refresh keys functionality will be implemented here.');
    // Placeholder for refresh functionality
}

// Populate users function
// document is the webpage. we define the id in the html. now we can get it
function populateUsers(users) {
    const userListDropdown = document.getElementById("userList");
    users.forEach(user => {
        const option = new Option(user[1], user[0]); // username as text, user_id as value
        userListDropdown.add(option);
    });
}

// Fetch users from server
$(document).ready(function() {
    fetch('/users')
        .then(response => response.json())
        .then(data => {
            data.users.forEach(user => {
                userInfo[user[0]] = user[1]; // Map user_id to username
            });
            console.log("User Info", userInfo);
            populateUsers(data.users);
        })
        .catch(error => console.error('Error fetching user info:', error));
});

// Handle user selection change
document.getElementById('userList').addEventListener('change', event => {
    peer_id = parseInt(event.target.value, 10); // Convert selected peer_id to integer
    clearChatBox();
    lastMessageId = 0;
    fetchMessages(); // Fetch messages for the new selection
});

// Clear chat box
function clearChatBox() {
    document.getElementById('messages').innerHTML = '';
}

// Fetch messages from server
function fetchMessages() {
    if (peer_id === -1) return; // Exit if no peer selected
    fetch(`/fetch_messages?last_message_id=${lastMessageId}&peer_id=${peer_id}`)
        .then(response => response.json())
        .then(data => {
            data.messages.forEach(message => {
                displayMessage(message);
                lastMessageId = message.message_id;
                console.log("Message type", message.message_type);
                if (message.message_type == "ECDH request" && message.sender_id == peer_id){
                    reply_to_ECDH(message.message_text);
                }
                if (message.message_type=='ECDH response' && message.sender_id == peer_id){
                    receive_ECDH_response(message.message_text);
                }
            });
        })
        .catch(error => console.error('Error fetching messages:', error));
}

// Display a single message
async function displayMessage(message) {
    const messagesContainer = document.getElementById('messages');
    const messageElement = document.createElement('div');

    // Determine sender and receiver strings
    const sender = message.sender_id == myID ? "me" : (userInfo[message.sender_id] || `User ${message.sender_id}`);
    const receiver = message.receiver_id == myID ? "me" : (userInfo[message.receiver_id] || `User ${message.receiver_id}`);

    let plaintext0;
    if (message.message_type === "normal"){
        plaintext0 = await decrypt(message.message_text, mySecretKey);
    }else {
        plaintext0 = message.message_text;
    }
    const plaintext = plaintext0;
    console.log("plaintext in display", plaintext);
    messageElement.textContent = `From ${sender} to ${receiver}: ${plaintext}`;
    messagesContainer.appendChild(messageElement);

}

// Periodically fetch new messages every second
setInterval(fetchMessages, 1000);

// Erase Chat function using fetch API
function eraseChat() {
    if (peer_id === -1) return; // Exit if no peer selected
    if (!confirm('Are you sure you want to erase the chat with '+userInfo[peer_id]+'?')) return; // Confirmation before erasing

    fetch(`/erase_chat`, {
        method: 'POST',  // A REST API should use POST if it leads to modifications
        headers: {
            'Content-Type': 'application/json', 
        },
        body: JSON.stringify({ peer_id: peer_id })
    })
    .then(response => {
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        return response.json(); // Assuming the server responds with JSON
    })
    .then(data => {
        console.log('Chat erased:', data);
        clearChatBox(); // Clear the chat display
    })
    .catch(error => {
        console.error('Error erasing chat:', error);
    });
}

async function initial_ECDH(){
    await generateKey();
    sendECDH_request();
}

async function receive_ECDH_response(otherpublickey){
    await generate_secret_key(otherpublickey);
}

async function reply_to_ECDH(otherpublickey){
    await generateKey();
    await sendECDH_response();
    await generate_secret_key(otherpublickey);
}

async function generate_secret_key(otherPublicKey){
    localStorage.setItem("otherPublicKey", otherPublicKey);
    console.log("Other public key", otherPublicKey);
    const jwkKey = JSON.parse(otherPublicKey);
  const publicKey = await window.crypto.subtle.importKey(
    "jwk",
    jwkKey,
    {
      name: "ECDH",
      namedCurve: "P-384",
    },
    true,
    []
  );
    mySecretKey = await deriveSecretKey(
      myKeyPair.privateKey,
      publicKey
    );
    console.log("My secret key", mySecretKey);
}

/*
Use the shared secret and salt to derive an
AES-GCM key using HKDF.
 */
function generateAesKey(secret, salt) {
    return window.crypto.subtle.deriveKey(
        {
            name: "HKDF",
            salt: salt,
            info: new Uint8Array('CHAT_KEY_Usr1to2'),
            hash: "SHA-256"
        },
        secret,
        {
            name: "AES-GCM",
            length: 256
        },
        true,
        ["encrypt", "decrypt"]
    );
}

/*
Encrypt
 */
async function encrypt(msg, secret) {
    let salt = await window.crypto.getRandomValues(new Uint8Array(16));
    let key = await generateAesKey(secret, salt);
    let iv = await window.crypto.getRandomValues(new Uint8Array(12));
    console.log("IV", iv);
    const encryptedData = await window.crypto.subtle.encrypt(
        {
            name: "AES-GCM",
            iv: iv
        },
        key,
        new TextEncoder().encode(msg)
    );
    const uintArray = new Uint8Array(encryptedData);
    console.log("uintArray", uintArray);
    const string = String.fromCharCode.apply(null, uintArray);
    let cipherText = btoa(string);
    console.log("cipher text", cipherText);
    return {ct: cipherText, iv: iv, salt: salt};
}

// Decrypt a message
async function decrypt(msg, secret) {
    try{
        const messageJs = JSON.parse(msg);
        let salt = new Uint8Array(Object.entries(messageJs.salt).map((char) => char[1]));
        let iv = new Uint8Array(Object.entries(messageJs.iv).map((char) => char[1]));
        console.log("salt1", salt);
        console.log("iv1", iv);
        let key = await generateAesKey(secret, salt);

        const ciphertext = messageJs.ct;
        console.log("ciphertext1", ciphertext);
        const string = atob(ciphertext);
        const uintArray = new Uint8Array([...string].map((char) => char.charCodeAt(0)));
        console.log("uintArray1", uintArray);

        const decryptedData = await window.crypto.subtle.decrypt(
            {
                name: "AES-GCM",
                iv: iv
            },
            key,
            uintArray
        );
        let plaintext = new TextDecoder().decode(decryptedData);
        console.log("plaintext", plaintext);
        return plaintext;
    }catch (e) {
        console.error(`${e}`);
    }

}


/**
 * generate keypair for ECDH
 */

async function generateKey() {
    myKeyPair = await window.crypto.subtle.generateKey(
    {
      name: "ECDH",
      namedCurve: "P-384",
    },
    true,
    ["deriveKey","deriveBits"],
  );
  console.log("Keypair generated", myKeyPair);
  myExportPublicKey = await window.crypto.subtle.exportKey(
    "jwk",
    myKeyPair.publicKey);
    console.log("Public key exported to jwk", myExportPublicKey);
    myExportPrivateKey = await window.crypto.subtle.exportKey("jwk", myKeyPair.privateKey);
    console.log("My private key", myExportPrivateKey);

    // save private key and public key to local storage
    localStorage.setItem("myPublicKey", JSON.stringify(myExportPublicKey));
    localStorage.setItem("myPrivateKey", JSON.stringify(myExportPrivateKey));
}

    /*
  Derive an AES key, given:
  - our ECDH private key
  - their ECDH public key
  */
  async function deriveSecretKey(privateKey, publicKey, salt) {
      return await window.crypto.subtle.deriveKey(
          {name: "ECDH", public: publicKey},
          privateKey,
          {name: "HKDF", hash: "SHA-256", salt: salt, info: new Uint8Array("CHAT_KEY")},
          false,
          ["deriveKey"]
      );
  }




// /*
//     Encrypt the message using the secret key.
//     Update the "ciphertextValue" box with a representation of part of
//     the ciphertext.
// */
// async function encrypt(secretKey) {
//     const ciphertextValue = document.querySelector(".ecdh .ciphertext-value");
//     ciphertextValue.textContent = "";
//     const decryptedValue = document.querySelector(".ecdh .decrypted-value");
//     decryptedValue.textContent = "";

//     iv = window.crypto.getRandomValues(new Uint8Array(12));
//     let encoded = getMessageEncoding();

//     ciphertext = await window.crypto.subtle.encrypt(
//       {
//         name: "AES-GCM",
//         iv: iv,
//       },
//       secretKey,
//       encoded
//     );

//     let buffer = new Uint8Array(ciphertext, 0, 5);
//     ciphertextValue.classList.add("fade-in");
//     ciphertextValue.addEventListener("animationend", () => {
//       ciphertextValue.classList.remove("fade-in");
//     });
//     ciphertextValue.textContent = `${buffer}...[${ciphertext.byteLength} bytes total]`;
// }

// /*
//   Decrypt the message using the secret key.
//   If the ciphertext was decrypted successfully,
//   update the "decryptedValue" box with the decrypted value.
//   If there was an error decrypting,
//   update the "decryptedValue" box with an error message.
//   */
// async function decrypt(secretKey) {
//     const decryptedValue = document.querySelector(".ecdh .decrypted-value");
//     decryptedValue.textContent = "";
//     decryptedValue.classList.remove("error");

//     try {
//       let decrypted = await window.crypto.subtle.decrypt(
//         {
//           name: "AES-GCM",
//           iv: iv,
//         },
//         secretKey,
//         ciphertext
//       );

//       let dec = new TextDecoder();
//       decryptedValue.classList.add("fade-in");
//       decryptedValue.addEventListener("animationend", () => {
//         decryptedValue.classList.remove("fade-in");
//       });
//       decryptedValue.textContent = dec.decode(decrypted);
//     } catch (e) {
//       decryptedValue.classList.add("error");
//       decryptedValue.textContent = "*** Decryption error ***";
//     }
// }

// const generateKeyPair = window.crypto.subtle.generateKey(
//     {
//       name: "ECDH",
//       namedCurve: "P-384"
//     },
//     false,
//     ["deriveKey"]
//   );



</script>
</body>
</html>
